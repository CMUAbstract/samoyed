#include <msp430.h>

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef LOGIC
#define LOG(...)
#define PRINTF(...)
#define BLOCK_PRINTF(...)
#define BLOCK_PRINTF_BEGIN(...)
#define BLOCK_PRINTF_END(...)
#define INIT_CONSOLE(...)
#else
#include <libio/console.h>
#endif
#include <libmsp/mem.h>
#include <libmsp/periph.h>
#include <libmsp/clock.h>
#include <libmsp/watchdog.h>
#include <libmsp/gpio.h>
#include <libcapybara/capybara.h>
#include <libcapybara/power.h>
#include <libjit/jit.h>
#include <libmspdriver/driverlib.h>

#include "pins.h"
#define CONT_POWER 0
#define QUICKRECALL 0
#define SW 1
// Clang complains about too large array.
// For recursive, over 6250 has a problem so let's not make it too large
#define ARR_SIZE 5000
//#define ARR_SIZE 50000
#define LOG(...)
#define ENERGY 1

void init();
volatile __attribute__((section(".upper.nv_vars"))) int data_src[ARR_SIZE] = {
#include "./src.txt"
};
volatile __attribute__((section(".upper.nv_vars"))) int data_dst[ARR_SIZE];

__nv unsigned int _jit_0_size = 65535;
int _jit_safe_0(int * dst, int * src, unsigned int size)  {
	unsigned int size_bak = size;
	if (size_bak <= _jit_0_size && !_jit_no_progress) {
;
	;
	;
	;
	__asm__ volatile ("MOVX.A R13, %0":"=m"(DMA1SA));
	__asm__ volatile ("MOVX.A R12, %0":"=m"(DMA1DA));
	// size in word
	DMA1SZ = size;
	uint16_t interruptState = __get_interrupt_state();
	__disable_interrupt();
	DMA1CTL |= (DMADT_1 | DMASRCINCR_3 | DMADSTINCR_3 | DMAEN | DMAREQ | DMAIE);
	__bis_SR_register(GIE + LPM0_bits); 
	__set_interrupt_state(interruptState);
		if (_jit_bndMayNeedUpdate) {
			_jit_0_size = size_bak;
			_jit_bndMayNeedUpdate = 0;
		}
		return 1;
	}
	return 0;
}
void safe_dma_transfer(int* dst, int* src, unsigned size) {
		int success = 0;
	if (src == dst) {
		if (size <= _jit_0_size) {
			recursiveUndoLog(src,  size << 1);
		}
	}
	undoLogPtr = undoLogPtr_tmp;
	undoLogCnt = undoLogCnt_tmp;
	PROTECT_BEGIN();
	undoLogPtr = undoLogPtr_tmp;
	undoLogCnt = undoLogCnt_tmp;
	if (src == dst) {
	}
	success = _jit_safe_0(dst, src, size);
	PROTECT_END();
	if (!success) {
;
	safe_dma_transfer(dst, src, size >> 1);
	safe_dma_transfer(dst + (size >> 1), src + (size >> 1), size >> 1);
	}
;
}
//void test_dma_transfer(int* dst, int* src, unsigned size) {
//	IF_ATOMIC(KNOB(size, 50000));
//	DMA1SA = src; // tmp
//	DMA1DA = dst;
//	__asm__ volatile ("MOVX.A R13, %0":"=m"(DMA1SA));
//	__asm__ volatile ("MOVX.A R12, %0":"=m"(DMA1DA));
//	// size in word
//	DMA1SZ = size;
//	uint16_t interruptState = __get_interrupt_state();
//	__disable_interrupt();
//	DMA1CTL |= (DMADT_1 | DMASRCINCR_3 | DMADSTINCR_3 | DMAEN | DMAREQ | DMAIE);
//	__bis_SR_register(GIE + LPM0_bits); 
//	__set_interrupt_state(interruptState);
//	ELSE();
//	safe_dma_transfer(dst, src, size >> 1);
//	safe_dma_transfer(dst + (size >> 1), src + (size >> 1), size >> 1);
//	END_IF();
//}
/*
	 void safe_dma_transfer(int* dst, int* src, unsigned size) {
	 IF_ATOMIC(KNOB(size, 50000));
	 __asm__ volatile ("MOVX.A R13, %0":"=m"(DMA1SA));
	 __asm__ volatile ("MOVX.A R12, %0":"=m"(DMA1DA));
// size in word
DMA1SZ = size;
uint16_t interruptState = __get_interrupt_state();
__disable_interrupt();
DMA1CTL |= (DMADT_1 | DMASRCINCR_3 | DMADSTINCR_3 | DMAEN | DMAREQ | DMAIE);
__bis_SR_register(GIE + LPM0_bits); 
__set_interrupt_state(interruptState);
ELSE();
safe_dma_transfer(dst, src, size >> 1);
safe_dma_transfer(dst + (size >> 1), src + (size >> 1), size >> 1);
END_IF();
}

void safe_dma_transfer(int* dst, int* src, unsigned size) {
IN(src, 0, size << 1);
OUT(dst, 0, size << 1);
PARAM(size);
SCALING_RULE_BEGIN();
safe_dma_transfer(dst, src, size >> 1);
safe_dma_transfer(dst + (size >> 1), src + (size >> 1), size >> 1);
SCALING_RULE_END();

__asm__ volatile ("MOVX.A R13, %0":"=m"(DMA1SA));
__asm__ volatile ("MOVX.A R12, %0":"=m"(DMA1DA));
// size in word
DMA1SZ = size;
uint16_t interruptState = __get_interrupt_state();
__disable_interrupt();
DMA1CTL |= (DMADT_1 | DMASRCINCR_3 | DMADSTINCR_3 | DMAEN | DMAREQ | DMAIE);
__bis_SR_register(GIE + LPM0_bits); 
__set_interrupt_state(interruptState);
}
 */

void dma_sw(int* dst, int* src, size_t size) {
	for (size_t i = 0; i < size; ++i)
		*(dst+i) = *(src+i);
}

// this should be generated by the compiler
int main()
{
	chkpt_mask_init = 1;
	init();
	#if ENERGY == 0
	restore_regs();
	#endif
	chkpt_mask_init = 0;
	#if ENERGY == 1
	P1OUT &= ~BIT3;
	P1DIR |= BIT3;
	char _jit_test_src[ 1 << 1];
	fill_with_rand(_jit_test_src,  1 << 1);
	char _jit_test_dst[ 1 << 1];
	PRINTF("CNT: %u %u\r\n", energy_overflow, energy_counter);
	energy_counter = 0;
	energy_overflow = 0;
	P1OUT |= BIT3;
	while (1) {
		safe_dma_transfer((int *)_jit_test_dst, (int *)_jit_test_src, 1);
		if (energy_counter == 0xFFFF) {
			energy_overflow = 1;
		}
		else {
			energy_counter = energy_counter + 1;
		}
	}
	#endif
	PROTECT_BEGIN();
	capybara_config_banks(0x0);
	PROTECT_END();

	while (1) {
		// memset cannot handle too large data (size overflow)
		//memset(&data_dst[0], 0, ARR_SIZE*sizeof(data_dst[0]));
		// for simple test only,
		data_dst[ARR_SIZE - 1] = 7;
		//data_src2[ARR_SIZE - 1] = 8;

#ifdef LOGIC
		GPIO(PORT_DBG, OUT) |= BIT(PIN_AUX_0);
		GPIO(PORT_DBG, OUT) &= ~BIT(PIN_AUX_0);
#else
		PROTECT_BEGIN();
		PRINTF("start %u\r\n", data_dst[ARR_SIZE - 1]);
		PROTECT_END();
#endif

#if QUICKRECALL == 1
		dma_transfer(&data_dst[0], &data_src[0], ARR_SIZE);	
#elif SW == 1
		dma_sw(&data_dst[0], &data_src[0], ARR_SIZE);
#else
		safe_dma_transfer(&data_dst[0], &data_src[0], ARR_SIZE);
#endif

#ifdef LOGIC
		GPIO(PORT_DBG, OUT) |= BIT(PIN_AUX_2);
		GPIO(PORT_DBG, OUT) &= ~BIT(PIN_AUX_2);
#else
		PROTECT_BEGIN();
		PRINTF("end %u\r\n", data_dst[ARR_SIZE-1]);
		PROTECT_END();
#endif
	}
	return 0;

}

void __attribute__((interrupt(DMA_VECTOR)))dmaIsrHandler(void) {
	if (DMA1CTL & DMAIFG)
		DMA1CTL &= ~DMAIFG;
	__bic_SR_register_on_exit(LPM0_bits);
}

void init()
{
	msp_watchdog_disable();
	msp_gpio_unlock();
	__enable_interrupt();
	capybara_wait_for_supply();
	capybara_config_pins();
	msp_clock_setup();

#if CONT_POWER == 0
	cb_rc_t deep_discharge_status = capybara_shutdown_on_deep_discharge();
	if (deep_discharge_status == CB_ERROR_ALREADY_DEEPLY_DISCHARGED)
		capybara_shutdown();
#endif

	INIT_CONSOLE();
	//GPIO(PORT_DBG, OUT) &= ~BIT(PIN_DBG0);
	//GPIO(PORT_DBG, DIR) |= BIT(PIN_DBG0);
#ifdef LOGIC
	GPIO(PORT_DBG, OUT) &= ~BIT(PIN_AUX_0);
	GPIO(PORT_DBG, OUT) &= ~BIT(PIN_AUX_1);
	GPIO(PORT_DBG, OUT) &= ~BIT(PIN_AUX_2);
	//GPIO(PORT_DBG, OUT) &= ~BIT(PIN_DBG0);

	GPIO(PORT_DBG, DIR) |= BIT(PIN_AUX_0);
	GPIO(PORT_DBG, DIR) |= BIT(PIN_AUX_1);
	GPIO(PORT_DBG, DIR) |= BIT(PIN_AUX_2);
	//GPIO(PORT_DBG, DIR) |= BIT(PIN_DBG0);

	GPIO(PORT_DBG, OUT) |= BIT(PIN_AUX_1);
	GPIO(PORT_DBG, OUT) &= ~BIT(PIN_AUX_1);
#else
	unsigned pc;
	__asm__ volatile ("MOV &0x4400, %0":"=m"(pc));
	PRINTF(".%x.%u\r\n", pc, _jit_0_size);
#endif
}
